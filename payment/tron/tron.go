package tron

import (
	"bytes"
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"github.com/chenqgp/abc/conf"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/chenqgp/abc"
	"github.com/chenqgp/abc/payNotice"
	"github.com/chenqgp/abc/third/telegram"
)

var TronIdUrl = conf.SchemeTLS + `api.trongrid.io/v1/accounts/%s/transactions/trc20?limit=10&page=1&contract_address=%s`

type rtnTronAccount struct {
	Data []struct {
		TransactionId string `json:"transaction_id"`
		TokenInfo     struct {
			Symbol   string `json:"symbol"`
			Address  string `json:"address"`
			Decimals int    `json:"decimals"`
			Name     string `json:"name"`
		} `json:"token_info"`
		BlockTimestamp int64  `json:"block_timestamp"`
		From           string `json:"from"`
		To             string `json:"to"`
		Type           string `json:"type"`
		Value          string `json:"value"`
	} `json:"data"`
	Success bool `json:"success"`
	Meta    struct {
		Links struct {
			Next string `json:"next"`
		} `json:"links"`
	} `json:"meta"`
}

func browser(address, contract string) (r rtnTronAccount) {
	c := http.Client{Timeout: 10 * time.Second}
	res, err := c.Get(fmt.Sprintf(TronIdUrl, address, contract))
	if err != nil {
		panic("tron " + err.Error())
	}
	defer res.Body.Close()
	var buf bytes.Buffer
	io.Copy(&buf, res.Body)
	abc.ParseJSON(buf.Bytes(), &r)
	return
}

type TransactionInfo struct {
	Id              string   `json:"id"`
	ContractResult  []string `json:"contractResult"`
	ContractAddress string   `json:"contract_address"`
	Receipt         struct {
		EnergyFee          int    `json:"energy_fee"`
		EnergyUsageTotal   int    `json:"energy_usage_total"`
		NetUsage           int    `json:"net_usage"`
		Result             string `json:"result"`
		EnergyPenaltyTotal int    `json:"energy_penalty_total"`
	} `json:"receipt"`
}

func GetTokenInfo(txid string) (*TransactionInfo, error) {
	m1 := make(map[string][]string)
	m1["Content-Type"] = []string{"application/json"}
	r := abc.DoRequest("POST", "https://api.trongrid.io/wallet/gettransactioninfobyid", strings.NewReader( fmt.Sprintf(`{"value": "%s"}`, txid)), m1)
	t := TransactionInfo{}
	err := json.Unmarshal(r, &t)
	if err != nil {
		return nil, err
	}
	return &t, nil
}

func Do(pid any) {
	p := abc.GetPaymentOne(fmt.Sprintf("type = 'deposit' AND status = 0 AND pay_name='USDT' AND id = %d", pid))
	if p.Id == 0 {
		return
	}

	// Get user's wallet.
	wallet, ok := abc.GetWallet(p.UserId)
	if !ok {
		return
	}
	b, _ := hex.DecodeString(wallet.PrivateKey)
	wallet.PrivateKey = string(AESDecrypt(b))
	// ------------------the system deduct all that if user wallet have any amounts of USDT--------------------

	// use the address of Tron to visit block browser.
	r := browser(wallet.Address, conf.USDTContract)

	// Recording into user wallet balance if usdt is ok.
	for _, item := range r.Data {
		if item.TokenInfo.Address == conf.USDTContract && item.To == wallet.Address {
			v := abc.ToFloat64(item.Value) / 1e6
			// Got usdt but the amount is less than it should be(deposit amount).
			if v < 190 {
				//telegram.SendMsg(telegram.TEXT, telegram.TEST, fmt.Sprintf("pid=%d, USDT存款不足存款要求，系统自动划转该笔额度. deposit = %.2f, conpon = %.2f, user input amount = %.2f\n", p.Id, p.Amount, p.PayFee, v))
				continue
			}
			payment := abc.GetPaymentOne(fmt.Sprintf("comment = '%s'", item.TransactionId))
			if payment.Id != 0 {
				continue
			}
			//检测是否已经确认
			t, err := GetTokenInfo(item.TransactionId)
			if err != nil {
				fmt.Println("Error getting: ", err.Error())
				continue
			}
			if t.Receipt.Result != "SUCCESS"{
				fmt.Println("t.Receipt.Result: ", t.Receipt.Result)
				continue
			}
			if stat, _ := payNotice.SuccessPay(p.OrderNo, v); stat == 1 {
				payNotice.SuccessPayNotice(p.Id, stat, v)
				abc.UpdatePayment(fmt.Sprintf("id = %d", pid), map[string]interface{}{
					"comment": item.TransactionId,
				})
				fmt.Printf("pid=%d  USDT存款开始上分：%.2f trxID=%s\n", p.Id, v, item.TransactionId)
				break
			}
		}
	}
	time.Sleep(200 * time.Millisecond)
	// ------------------the system deduct all that if user wallet have any amounts of USDT--------------------
	balance := USDTBalance(wallet.Address)
	if balance == 0 {
		fmt.Println("Balance = ", balance)
		return
	}
	time.Sleep(200 * time.Millisecond)
	trxBalance := TrxBalance(wallet.Address)
	// Determine how much the feeLimit to pay.
	var feeTRX int64
	feeUSDT := int64(15)
	//energyFactor := abc.ToFloat64(GetContractInfo().ContractState.EnergyFactor)
	//energyUsed := abc.ToFloat64(TriggerConstantContract(wallet.Address).EnergyUsed)
	//fee := energyUsed * (1 + energyFactor/10000) * 0.00042
	//feeInt = abc.ToInt64(math.Ceil(fee))
	feeTRX = feeUSDT * 1e6 - trxBalance
	if feeTRX < 0 {
		feeTRX = 0
	}
	time.Sleep(200 * time.Millisecond)
	// Transfer trx(feeLimit) to user's wallet which have generated by CRM,
	// then the wallet transfer usdt to the cold wallet throught the feeLimit trx.
	if feeTRX > 0{
		trxBalance = TrxBalance(conf.TRCAddress)
		if trxBalance < feeTRX + 1268000 {
			fmt.Println("conf.TRCAddress trxBalance = ", trxBalance)
			telegram.SendMsg(telegram.TEXT, telegram.TEST, fmt.Sprintf("钱包trx不足. trx balance = %d, trx fee = %d\n", trxBalance/1e6, feeTRX))
			return
		}
		time.Sleep(200 * time.Millisecond)
		TransferTrx(conf.TRCAddress, wallet.Address, conf.TRCPrivate, feeTRX/1e6 + 1)
	}
	time.Sleep(200 * time.Millisecond)
	USDTTransfer(wallet.Address, conf.ColdTRCAddress, wallet.PrivateKey, balance, feeUSDT)
}

func CreateUserWallet(done context.CancelFunc) {
	defer done()
	count := abc.WalletCount("user_id = 0")
	totalCycle := 3
	if int(count) < totalCycle {
		for i := 0; i < totalCycle-int(count); i++ {
			address, privateHex := CreateWallet()
			if address == "" || privateHex == "" {
				if i == 0 {
					done()
				}
				continue
			}
			var wallet abc.UserWallet
			wallet.Address = address
			wallet.PrivateKey = hex.EncodeToString(AESEncrypt([]byte(privateHex)))
			wallet.Symbol = "trc20"
			wallet.CreateTime = abc.FormatNow()
			wallet.Status = 1
			abc.WalletInsert(wallet)
			if i == 0 {
				done()
			}
			time.Sleep(time.Second)
		}
	}
}
